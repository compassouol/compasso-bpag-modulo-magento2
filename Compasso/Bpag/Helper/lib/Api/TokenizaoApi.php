<?php
/**
 * TokenizaoApi
 * PHP version 5
 *
 * @category Class
 * @package  Compasso\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API BPAG Gateway de Pagamentos
 *
 * UOL Diveo Payment PCI Gateway  # Authenticação  Para autenticação com a plataforma de pagamentos o sistema cliente deve se encarregar do envio dos seguintes headers    Header  | Obrigatório | Descrição | Exemplo  --------|-------------|---------|----------  Merchant | Sim | Empresa fornecida pelo UOL Diveo | uoldiveo  Account | Sim | Unidade fornecida pelo UOL Diveo | uoldiveo  Date | Sim | Data atual no formato `EEE, d MMM yyyy HH:mm:ss z` | Wed, 25 Jun 2018 12:00:00 GMT  Authorization | Sim | Chave calculada com base na requisição | UOLWS access-id:signature:hmac-algorithm:protocol-version  OnBehalfOfAccessId | Não | Em caso de utilização de Access Id/Client Secret diferente ao do Merchant, deve ser enviado o Access Id do Merchant | e401cf78cc8d85fd92f1adda74a4c160    ## Descrição do Protocolo da ApiSecurity  Para todo cliente de um web service deve ser criada sua respectiva credencial.  As credenciais são formadas por access-id e secret-key.  O access-id é um identificador único e aleatório de um cliente(exemplo: 99d1932acad7a4ce93ea321495b96cde)  A secret-key é um valor aleatório criado de forma segura para melhor atender as necessidades criptograficas do algoritmo de assinatura (exemplo: G8ZnZ1EkSDPcsgBXLoAQeyhLyEfBXNSkezSqnW/akZQ=)    Essa credencial deverá ser inserida no Header Authorization de todas as requisições do cliente de forma a identificá-lo, como mostrado abaixo.    - **Authorization**: UOLWS access-id:signature:hmac-algorithm:protocol-version  - **signature**: explicado abaixo em 'Calculando a Assinatura'  - **hash-algorithm**: Identificador de um algoritmo de HMAC utilizado para assinar a requisição. As opções são 's1' para HMacSHA1 e 's2' para HMacSHA256. Cada web service pode escolher quais dos algoritmos ele suporta e, caso esse parâmetro seja omitido, qual é o algoritmo padrão. Outras opções podem ser definidas pelos webservices, caso necessário. deve ser usado apenas na versão 0.2 do protocolo.  - **protocol-version**: versão do protocolo de autenticação UOLWS. Opções são 0.1 ou 0.2.    ## Calculando a Assinatura  ### Protocolo Versão 0.2    - **signature**: Base64( hmac-algorithm( secret-key, string-to-sign) );  - **string-to-sign**: `HTTP-Verb + \"\\n\" + Content-MD5 + \"\\n\" + Content-Type + \"\\n\" + Date + \"\\n\" + Canonicalized-X-UOL-Headers + HTTP-Path-Info`  - **HTTP-Verb**: O verbo da requisição HTTP; POST, GET, DELETE etc.    > Os headers Content-MD5, Content-Type e Date tem natureza posicional, por isso, o nome do Header não deve ser inserido na StringToSign, apenas seus valores. Se os Headers Content-Type e Content-MD5 não estiverem presentes na requisição(ambos são opcionais para requisições PUT e sem sentido para GET) considerar a string vazia como o seu valor, ficando apenas o \"\\n\" na respectiva posição. O valor do Header Date é obrigatório.    - **Canonicalized-X-UOL-Headers**     1.  Converter os Headers que comecem com 'X-UOL-' para lower-case. Por exemplo, 'X-UOL-AlternateKey' se torna 'x-uol-alternatekey'     2. Ordenar os Headers lexicograficamente pelos seus nomes. Desse mode x-uol-alternatekey vem antes de x-uol-date.     3. Combinar os Header com o mesmo nome em um Header único com os seus valores separados por vírgulas e um espaços em branco entre os valores. Por exemplo, 'x-uol-alternate-key: ip=127.0.0.1' e 'x-uol-alternate-key: idt_person=1237654' devem ser combinados em 'x-uol-alternate-key: ip=127.0.0.1, idt_person=1237654'     4. Fazer 'Unfold' dos Headers longos, removendo LWS(rfc2616, sessão 2.2) por um único espaço em branco.     5. Remover os espaços entre os dois pontos e o valor do header. Por exemplo 'x-uol-alternate-key: ip=127.0.0.1,idt_person=1237654' se torna 'x-uol-alternate-key:ip=127.0.0.1,idt_person=1237654'     6. Finalmente, adicione um 'new-line'(\\n) para cada Header da lista, resultando em uma só String.    - **HTTP-Path-Info**: A parte de URL da requisição que vai de após nome do servidor até a query string. Exemplos    Primeira Linha da requisição  | HTTP-Path-Info  --------|-------------  GET http://foo.bar/a.html | /a.html  HEAD /xyz?a=b HTTP/1.1 | /xyz  POST /some/path.html HTTP/1.1 | /some/path.html    ### Protocolo Versão 0.1    > Devido a questões de segurança este protocolo foi descontinuado
 *
 * OpenAPI spec version: 3.0.X
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.14
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Compasso\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Compasso\Client\ApiException;
use Compasso\Client\Configuration;
use Compasso\Client\HeaderSelector;
use Compasso\Client\ObjectSerializer;

/**
 * TokenizaoApi Class Doc Comment
 *
 * @category Class
 * @package  Compasso\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TokenizaoApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createUsingPOST
     *
     * Criação de um novo token
     *
     * @param  \Compasso\Bpag\Model\Api\TokenRequest $token_request Dados do cartão de crédito (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Compasso\Bpag\Model\Api\TokenResponse
     */
    public function createUsingPOST($token_request)
    {
        list($response) = $this->createUsingPOSTWithHttpInfo($token_request);
        return $response;
    }

    /**
     * Operation createUsingPOSTWithHttpInfo
     *
     * Criação de um novo token
     *
     * @param  \Compasso\Bpag\Model\Api\TokenRequest $token_request Dados do cartão de crédito (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Compasso\Bpag\Model\Api\TokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUsingPOSTWithHttpInfo($token_request)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->createUsingPOSTRequest($token_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\TokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUsingPOSTAsync
     *
     * Criação de um novo token
     *
     * @param  \Compasso\Bpag\Model\Api\TokenRequest $token_request Dados do cartão de crédito (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUsingPOSTAsync($token_request)
    {
        return $this->createUsingPOSTAsyncWithHttpInfo($token_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUsingPOSTAsyncWithHttpInfo
     *
     * Criação de um novo token
     *
     * @param  \Compasso\Bpag\Model\Api\TokenRequest $token_request Dados do cartão de crédito (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUsingPOSTAsyncWithHttpInfo($token_request)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->createUsingPOSTRequest($token_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUsingPOST'
     *
     * @param  \Compasso\Bpag\Model\Api\TokenRequest $token_request Dados do cartão de crédito (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createUsingPOSTRequest($token_request)
    {
        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling createUsingPOST'
            );
        }

        $resourcePath = '/v1/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($token_request)) {
            $_tempBody = $token_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findByCustomerIdAndTokenIdUsingGET
     *
     * Consulta os dados do cartão através do identificador
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $token Identificador do token (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Compasso\Bpag\Model\Api\TokenResponse
     */
    public function findByCustomerIdAndTokenIdUsingGET($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token)
    {
        list($response) = $this->findByCustomerIdAndTokenIdUsingGETWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token);
        return $response;
    }

    /**
     * Operation findByCustomerIdAndTokenIdUsingGETWithHttpInfo
     *
     * Consulta os dados do cartão através do identificador
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $token Identificador do token (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Compasso\Bpag\Model\Api\TokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function findByCustomerIdAndTokenIdUsingGETWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->findByCustomerIdAndTokenIdUsingGETRequest($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\TokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findByCustomerIdAndTokenIdUsingGETAsync
     *
     * Consulta os dados do cartão através do identificador
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $token Identificador do token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByCustomerIdAndTokenIdUsingGETAsync($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token)
    {
        return $this->findByCustomerIdAndTokenIdUsingGETAsyncWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findByCustomerIdAndTokenIdUsingGETAsyncWithHttpInfo
     *
     * Consulta os dados do cartão através do identificador
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $token Identificador do token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByCustomerIdAndTokenIdUsingGETAsyncWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->findByCustomerIdAndTokenIdUsingGETRequest($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findByCustomerIdAndTokenIdUsingGET'
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $token Identificador do token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findByCustomerIdAndTokenIdUsingGETRequest($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $token)
    {
        // verify the required parameter 'x_uol_cripto_type' is set
        if ($x_uol_cripto_type === null || (is_array($x_uol_cripto_type) && count($x_uol_cripto_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_type when calling findByCustomerIdAndTokenIdUsingGET'
            );
        }
        // verify the required parameter 'x_uol_cripto_transformation' is set
        if ($x_uol_cripto_transformation === null || (is_array($x_uol_cripto_transformation) && count($x_uol_cripto_transformation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_transformation when calling findByCustomerIdAndTokenIdUsingGET'
            );
        }
        // verify the required parameter 'x_uol_cripto_key_size' is set
        if ($x_uol_cripto_key_size === null || (is_array($x_uol_cripto_key_size) && count($x_uol_cripto_key_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_key_size when calling findByCustomerIdAndTokenIdUsingGET'
            );
        }
        // verify the required parameter 'x_uol_cripto_key' is set
        if ($x_uol_cripto_key === null || (is_array($x_uol_cripto_key) && count($x_uol_cripto_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_key when calling findByCustomerIdAndTokenIdUsingGET'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling findByCustomerIdAndTokenIdUsingGET'
            );
        }

        $resourcePath = '/v1/detoken/{token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_uol_cripto_type !== null) {
            $headerParams['x-uol-cripto.type'] = ObjectSerializer::toHeaderValue($x_uol_cripto_type);
        }
        // header params
        if ($x_uol_cripto_transformation !== null) {
            $headerParams['x-uol-cripto.transformation'] = ObjectSerializer::toHeaderValue($x_uol_cripto_transformation);
        }
        // header params
        if ($x_uol_cripto_key_size !== null) {
            $headerParams['x-uol-cripto.keySize'] = ObjectSerializer::toHeaderValue($x_uol_cripto_key_size);
        }
        // header params
        if ($x_uol_cripto_key !== null) {
            $headerParams['x-uol-cripto.key'] = ObjectSerializer::toHeaderValue($x_uol_cripto_key);
        }

        // path params
        if ($token !== null) {
            $resourcePath = str_replace(
                '{' . 'token' . '}',
                ObjectSerializer::toPathValue($token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findByCustomerUsingGET
     *
     * Consulta a lista de tokens de cliente
     *
     * @param  string $customer_id Identificação do cliente no sistema da empresa (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Compasso\Bpag\Model\Api\TokenResponse[]
     */
    public function findByCustomerUsingGET($customer_id)
    {
        list($response) = $this->findByCustomerUsingGETWithHttpInfo($customer_id);
        return $response;
    }

    /**
     * Operation findByCustomerUsingGETWithHttpInfo
     *
     * Consulta a lista de tokens de cliente
     *
     * @param  string $customer_id Identificação do cliente no sistema da empresa (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Compasso\Bpag\Model\Api\TokenResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function findByCustomerUsingGETWithHttpInfo($customer_id)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse[]';
        $request = $this->findByCustomerUsingGETRequest($customer_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\TokenResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findByCustomerUsingGETAsync
     *
     * Consulta a lista de tokens de cliente
     *
     * @param  string $customer_id Identificação do cliente no sistema da empresa (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByCustomerUsingGETAsync($customer_id)
    {
        return $this->findByCustomerUsingGETAsyncWithHttpInfo($customer_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findByCustomerUsingGETAsyncWithHttpInfo
     *
     * Consulta a lista de tokens de cliente
     *
     * @param  string $customer_id Identificação do cliente no sistema da empresa (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByCustomerUsingGETAsyncWithHttpInfo($customer_id)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse[]';
        $request = $this->findByCustomerUsingGETRequest($customer_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findByCustomerUsingGET'
     *
     * @param  string $customer_id Identificação do cliente no sistema da empresa (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findByCustomerUsingGETRequest($customer_id)
    {
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling findByCustomerUsingGET'
            );
        }

        $resourcePath = '/v1/token/customer-id/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findByMerchantTokenAliasUsingGET
     *
     * Consulta os dados do cartão através dos campos Customer ID e Token Alias
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $customer_id Identification of customer on merchant system (required)
     * @param  string $token_alias Identification of token on merchant system (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Compasso\Bpag\Model\Api\TokenResponse
     */
    public function findByMerchantTokenAliasUsingGET($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias)
    {
        list($response) = $this->findByMerchantTokenAliasUsingGETWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias);
        return $response;
    }

    /**
     * Operation findByMerchantTokenAliasUsingGETWithHttpInfo
     *
     * Consulta os dados do cartão através dos campos Customer ID e Token Alias
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $customer_id Identification of customer on merchant system (required)
     * @param  string $token_alias Identification of token on merchant system (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Compasso\Bpag\Model\Api\TokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function findByMerchantTokenAliasUsingGETWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->findByMerchantTokenAliasUsingGETRequest($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\TokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findByMerchantTokenAliasUsingGETAsync
     *
     * Consulta os dados do cartão através dos campos Customer ID e Token Alias
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $customer_id Identification of customer on merchant system (required)
     * @param  string $token_alias Identification of token on merchant system (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByMerchantTokenAliasUsingGETAsync($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias)
    {
        return $this->findByMerchantTokenAliasUsingGETAsyncWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findByMerchantTokenAliasUsingGETAsyncWithHttpInfo
     *
     * Consulta os dados do cartão através dos campos Customer ID e Token Alias
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $customer_id Identification of customer on merchant system (required)
     * @param  string $token_alias Identification of token on merchant system (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByMerchantTokenAliasUsingGETAsyncWithHttpInfo($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->findByMerchantTokenAliasUsingGETRequest($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findByMerchantTokenAliasUsingGET'
     *
     * @param  string $x_uol_cripto_type Tipo de criptografia (required)
     * @param  string $x_uol_cripto_transformation Cifra de criptografia (required)
     * @param  int $x_uol_cripto_key_size Tamanho da chave criptográfica (required)
     * @param  string $x_uol_cripto_key Chave pública (required)
     * @param  string $customer_id Identification of customer on merchant system (required)
     * @param  string $token_alias Identification of token on merchant system (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findByMerchantTokenAliasUsingGETRequest($x_uol_cripto_type, $x_uol_cripto_transformation, $x_uol_cripto_key_size, $x_uol_cripto_key, $customer_id, $token_alias)
    {
        // verify the required parameter 'x_uol_cripto_type' is set
        if ($x_uol_cripto_type === null || (is_array($x_uol_cripto_type) && count($x_uol_cripto_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_type when calling findByMerchantTokenAliasUsingGET'
            );
        }
        // verify the required parameter 'x_uol_cripto_transformation' is set
        if ($x_uol_cripto_transformation === null || (is_array($x_uol_cripto_transformation) && count($x_uol_cripto_transformation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_transformation when calling findByMerchantTokenAliasUsingGET'
            );
        }
        // verify the required parameter 'x_uol_cripto_key_size' is set
        if ($x_uol_cripto_key_size === null || (is_array($x_uol_cripto_key_size) && count($x_uol_cripto_key_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_key_size when calling findByMerchantTokenAliasUsingGET'
            );
        }
        // verify the required parameter 'x_uol_cripto_key' is set
        if ($x_uol_cripto_key === null || (is_array($x_uol_cripto_key) && count($x_uol_cripto_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_uol_cripto_key when calling findByMerchantTokenAliasUsingGET'
            );
        }
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling findByMerchantTokenAliasUsingGET'
            );
        }
        // verify the required parameter 'token_alias' is set
        if ($token_alias === null || (is_array($token_alias) && count($token_alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_alias when calling findByMerchantTokenAliasUsingGET'
            );
        }

        $resourcePath = '/v1/detoken/customer-id/{customerId}/token-alias/{tokenAlias}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_uol_cripto_type !== null) {
            $headerParams['x-uol-cripto.type'] = ObjectSerializer::toHeaderValue($x_uol_cripto_type);
        }
        // header params
        if ($x_uol_cripto_transformation !== null) {
            $headerParams['x-uol-cripto.transformation'] = ObjectSerializer::toHeaderValue($x_uol_cripto_transformation);
        }
        // header params
        if ($x_uol_cripto_key_size !== null) {
            $headerParams['x-uol-cripto.keySize'] = ObjectSerializer::toHeaderValue($x_uol_cripto_key_size);
        }
        // header params
        if ($x_uol_cripto_key !== null) {
            $headerParams['x-uol-cripto.key'] = ObjectSerializer::toHeaderValue($x_uol_cripto_key);
        }

        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }
        // path params
        if ($token_alias !== null) {
            $resourcePath = str_replace(
                '{' . 'tokenAlias' . '}',
                ObjectSerializer::toPathValue($token_alias),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findByTokenUsingGET
     *
     * Consulta de token por identificador
     *
     * @param  string $token Identificador do token (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Compasso\Bpag\Model\Api\TokenResponse
     */
    public function findByTokenUsingGET($token)
    {
        list($response) = $this->findByTokenUsingGETWithHttpInfo($token);
        return $response;
    }

    /**
     * Operation findByTokenUsingGETWithHttpInfo
     *
     * Consulta de token por identificador
     *
     * @param  string $token Identificador do token (required)
     *
     * @throws \Compasso\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Compasso\Bpag\Model\Api\TokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function findByTokenUsingGETWithHttpInfo($token)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->findByTokenUsingGETRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\TokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Compasso\Bpag\Model\Api\ExceptionHandlerMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findByTokenUsingGETAsync
     *
     * Consulta de token por identificador
     *
     * @param  string $token Identificador do token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByTokenUsingGETAsync($token)
    {
        return $this->findByTokenUsingGETAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findByTokenUsingGETAsyncWithHttpInfo
     *
     * Consulta de token por identificador
     *
     * @param  string $token Identificador do token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findByTokenUsingGETAsyncWithHttpInfo($token)
    {
        $returnType = '\Compasso\Bpag\Model\Api\TokenResponse';
        $request = $this->findByTokenUsingGETRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findByTokenUsingGET'
     *
     * @param  string $token Identificador do token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findByTokenUsingGETRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling findByTokenUsingGET'
            );
        }

        $resourcePath = '/v1/token/{token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($token !== null) {
            $resourcePath = str_replace(
                '{' . 'token' . '}',
                ObjectSerializer::toPathValue($token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
